# .github/workflows/daily-notifications.yml
# PRODUCTION-GRADE DAILY NOTIFICATIONS SCHEDULER
# VERSION: 1.1 - OPTION D CONFIGURATION
# SCHEDULE: 8 AM, 12 PM, 4 PM, 8 PM UTC (4 executions daily)
# IMPLEMENTATION DATE: 2025-01-08

name: ðŸ”” Daily Notifications Scheduler

# SCHEDULING CONFIGURATION - OPTION D SELECTED
# RULE: UTC timezone for all schedule expressions
# RULE: Cron format - minute hour day month weekday
# CONFIGURATION: Targeted execution times for optimal timezone coverage
on:
  schedule:
    # OPTION D: Specific times (8 AM, 12 PM, 4 PM, 8 PM UTC)
    # RATIONALE: Provides 4 strategic execution windows to cover global timezones
    # COVERAGE: Ensures users receive notifications during appropriate hours
    - cron: '0 8,12,16,20 * * *'
  
  # MANUAL TRIGGER CAPABILITY
  # PURPOSE: Testing and emergency execution
  workflow_dispatch:
    inputs:
      force_execution:
        description: 'Force execution (bypasses throttling)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

# GLOBAL ENVIRONMENT CONFIGURATION
env:
  NOTIFICATION_TIMEOUT: 30
  MAX_RETRIES: 3
  RETRY_DELAY: 5

# EXECUTION JOBS DEFINITION
jobs:
  # PRIMARY JOB: NOTIFICATION TRIGGER EXECUTION
  trigger-notifications:
    name: ðŸ“§ Execute Daily Notifications
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    # EXECUTION STRATEGY
    strategy:
      fail-fast: true
      max-parallel: 1
    
    # IMPLEMENTATION STEPS
    steps:
      # STEP 1: ENVIRONMENT PREPARATION
      - name: ðŸ”§ Environment Setup
        id: setup
        run: |
          echo "ðŸš€ Initializing notification trigger execution"
          echo "ðŸ“… Execution timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "ðŸ• Schedule: Option D - 8AM, 12PM, 4PM, 8PM UTC"
          echo "ðŸ”§ Runner OS: ${{ runner.os }}"
          echo "ðŸ“ Workflow: ${{ github.workflow }}"
          echo "ðŸ”€ Event: ${{ github.event_name }}"
          
          # Determine execution window for logging
          CURRENT_HOUR=$(date -u +%H)
          case $CURRENT_HOUR in
            08) EXECUTION_WINDOW="Morning (8 AM UTC)" ;;
            12) EXECUTION_WINDOW="Midday (12 PM UTC)" ;;
            16) EXECUTION_WINDOW="Afternoon (4 PM UTC)" ;;
            20) EXECUTION_WINDOW="Evening (8 PM UTC)" ;;
            *) EXECUTION_WINDOW="Manual/Off-Schedule" ;;
          esac
          
          echo "ðŸŒ Execution Window: $EXECUTION_WINDOW"
          
          # Set output variables for subsequent steps
          echo "execution_id=notify_$(date +%s)" >> $GITHUB_OUTPUT
          echo "start_time=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT
          echo "execution_window=$EXECUTION_WINDOW" >> $GITHUB_OUTPUT

      # STEP 2: CONNECTIVITY VALIDATION
      - name: ðŸŒ Supabase Connectivity Test
        id: connectivity
        timeout-minutes: 2
        run: |
          echo "ðŸ” Testing Supabase endpoint connectivity"
          
          # Test basic connectivity to Supabase
          if curl -s --max-time 10 "${{ secrets.SUPABASE_URL }}/health" > /dev/null; then
            echo "âœ… Supabase endpoint reachable"
          else
            echo "âš ï¸  Supabase health endpoint not reachable, proceeding with function call"
          fi
          
          # Validate URL format
          if [[ "${{ secrets.SUPABASE_URL }}" =~ ^https://[a-zA-Z0-9]+\.supabase\.co$ ]]; then
            echo "âœ… Supabase URL format valid"
          else
            echo "âŒ Invalid Supabase URL format"
            exit 1
          fi

      # STEP 3: CORE NOTIFICATION EXECUTION
      - name: ðŸ“¨ Execute Notification Function
        id: execute
        timeout-minutes: 5
        run: |
          echo "ðŸŽ¯ Executing daily notification function"
          echo "ðŸ• Execution Window: ${{ steps.setup.outputs.execution_window }}"
          echo "ðŸ”— Target URL: ${{ secrets.SUPABASE_URL }}/rest/v1/rpc/handle_schedule_daily_notifications"
          
          # Prepare force execution parameter
          FORCE_PARAM=""
          if [[ "${{ github.event.inputs.force_execution }}" == "true" ]]; then
            echo "âš¡ Force execution mode enabled"
            FORCE_PARAM=',"force":true'
          fi
          
          # Execute function with retry logic
          RETRY_COUNT=0
          MAX_RETRIES=${{ env.MAX_RETRIES }}
          SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$SUCCESS" != "true" ]; do
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "ðŸ”„ Attempt $RETRY_COUNT of $MAX_RETRIES"
            
            # Execute HTTP request with comprehensive error capture
            RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}\nTIME_TOTAL:%{time_total}" \
              --max-time ${{ env.NOTIFICATION_TIMEOUT }} \
              --retry 0 \
              -X POST "${{ secrets.SUPABASE_URL }}/rest/v1/rpc/handle_schedule_daily_notifications" \
              -H "apikey: ${{ secrets.SUPABASE_ANON_KEY }}" \
              -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
              -H "Content-Type: application/json" \
              -H "User-Agent: GitHub-Actions-DailyNotifications/1.1-OptionD" \
              -d "{\"execution_source\":\"github_actions_option_d\",\"execution_id\":\"${{ steps.setup.outputs.execution_id }}\",\"execution_window\":\"${{ steps.setup.outputs.execution_window }}\"${FORCE_PARAM}}" \
              2>&1) || true
            
            # Extract response components
            HTTP_STATUS=$(echo "$RESPONSE" | grep -o 'HTTP_STATUS:[0-9]*' | cut -d: -f2)
            TIME_TOTAL=$(echo "$RESPONSE" | grep -o 'TIME_TOTAL:[0-9.]*' | cut -d: -f2)
            RESPONSE_BODY=$(echo "$RESPONSE" | sed '/HTTP_STATUS:/d' | sed '/TIME_TOTAL:/d')
            
            echo "ðŸ“Š HTTP Status: ${HTTP_STATUS:-'UNKNOWN'}"
            echo "â±ï¸  Request Duration: ${TIME_TOTAL:-'UNKNOWN'}s"
            echo "ðŸ“„ Response Body: $RESPONSE_BODY"
            
            # Evaluate response success
            if [ "${HTTP_STATUS:-0}" -eq 200 ]; then
              # Additional JSON validation for successful responses
              if echo "$RESPONSE_BODY" | grep -q '"success"'; then
                echo "âœ… Function execution successful"
                SUCCESS=true
                
                # Extract key metrics from response
                USERS_PROCESSED=$(echo "$RESPONSE_BODY" | grep -o '"users_processed":[0-9]*' | cut -d: -f2)
                NOTIFICATIONS_SCHEDULED=$(echo "$RESPONSE_BODY" | grep -o '"notificationsScheduled":[0-9]*' | cut -d: -f2)
                
                echo "ðŸ‘¥ Users Processed: ${USERS_PROCESSED:-'N/A'}"
                echo "ðŸ“§ Notifications Scheduled: ${NOTIFICATIONS_SCHEDULED:-'N/A'}"
                
                # Set outputs for success reporting
                echo "users_processed=${USERS_PROCESSED:-0}" >> $GITHUB_OUTPUT
                echo "notifications_scheduled=${NOTIFICATIONS_SCHEDULED:-0}" >> $GITHUB_OUTPUT
                echo "execution_successful=true" >> $GITHUB_OUTPUT
                break
              else
                echo "âš ï¸  HTTP 200 but response indicates failure"
                echo "ðŸ” Response content: $RESPONSE_BODY"
              fi
            elif [ "${HTTP_STATUS:-0}" -eq 429 ]; then
              echo "ðŸš« Rate limited (HTTP 429) - will retry after delay"
            elif [ "${HTTP_STATUS:-0}" -eq 503 ]; then
              echo "ðŸ”§ Service unavailable (HTTP 503) - will retry after delay"
            else
              echo "âŒ Request failed with HTTP status: ${HTTP_STATUS:-'UNKNOWN'}"
              echo "ðŸ” Error response: $RESPONSE_BODY"
            fi
            
            # Retry delay (except on last attempt)
            if [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$SUCCESS" != "true" ]; then
              DELAY_TIME=$((RETRY_DELAY * RETRY_COUNT))
              echo "â³ Waiting ${DELAY_TIME}s before retry..."
              sleep $DELAY_TIME
            fi
          done
          
          # Final evaluation
          if [ "$SUCCESS" != "true" ]; then
            echo "ðŸ’¥ All retry attempts exhausted - execution failed"
            echo "execution_successful=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      # STEP 4: SUCCESS LOGGING AND REPORTING
      - name: ðŸ“ˆ Success Reporting
        if: success() && steps.execute.outputs.execution_successful == 'true'
        run: |
          echo "ðŸŽ‰ EXECUTION COMPLETED SUCCESSFULLY"
          echo "=================================================="
          echo "ðŸ“… Start Time: ${{ steps.setup.outputs.start_time }}"
          echo "ðŸ“… End Time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "ðŸ• Execution Window: ${{ steps.setup.outputs.execution_window }}"
          echo "ðŸ†” Execution ID: ${{ steps.setup.outputs.execution_id }}"
          echo "ðŸ‘¥ Users Processed: ${{ steps.execute.outputs.users_processed }}"
          echo "ðŸ“§ Notifications Scheduled: ${{ steps.execute.outputs.notifications_scheduled }}"
          echo "ðŸ”„ Event Type: ${{ github.event_name }}"
          echo "ðŸ“‹ Schedule: Option D (8AM, 12PM, 4PM, 8PM UTC)"
          echo "=================================================="
          
          # Calculate next execution time
          CURRENT_HOUR=$(date -u +%H)
          case $CURRENT_HOUR in
            08) NEXT_EXECUTION="12:00 PM UTC (Today)" ;;
            12) NEXT_EXECUTION="4:00 PM UTC (Today)" ;;
            16) NEXT_EXECUTION="8:00 PM UTC (Today)" ;;
            20) NEXT_EXECUTION="8:00 AM UTC (Tomorrow)" ;;
            *) NEXT_EXECUTION="Next scheduled time (8AM, 12PM, 4PM, or 8PM UTC)" ;;
          esac
          
          echo "â° Next Scheduled Execution: $NEXT_EXECUTION"
          
          # Log to job summary
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## âœ… Daily Notifications - Execution Successful
          
          | Metric | Value |
          |--------|--------|
          | ðŸ“… Execution Time | $(date -u '+%Y-%m-%d %H:%M:%S UTC') |
          | ðŸ• Execution Window | ${{ steps.setup.outputs.execution_window }} |
          | ðŸ†” Execution ID | \`${{ steps.setup.outputs.execution_id }}\` |
          | ðŸ‘¥ Users Processed | ${{ steps.execute.outputs.users_processed }} |
          | ðŸ“§ Notifications Scheduled | ${{ steps.execute.outputs.notifications_scheduled }} |
          | ðŸ”„ Trigger Type | ${{ github.event_name }} |
          | ðŸ“‹ Schedule Type | Option D (4 times daily) |
          
          ### ðŸ“Š Schedule Information
          **Execution Times (UTC):** 8:00 AM, 12:00 PM, 4:00 PM, 8:00 PM
          
          **Next Execution:** $NEXT_EXECUTION
          
          ### ðŸŒ Timezone Coverage
          This schedule provides optimal coverage for users across global timezones with 4 strategic execution windows.
          EOF

      # STEP 5: FAILURE HANDLING AND DIAGNOSTICS
      - name: ðŸš¨ Failure Diagnostics
        if: failure()
        run: |
          echo "ðŸ’¥ EXECUTION FAILED - DIAGNOSTIC INFORMATION"
          echo "=================================================="
          echo "ðŸ“… Failure Time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "ðŸ• Scheduled Window: ${{ steps.setup.outputs.execution_window }}"
          echo "ðŸ†” Execution ID: ${{ steps.setup.outputs.execution_id }}"
          echo "ðŸ”„ Event Type: ${{ github.event_name }}"
          echo "ðŸ”§ Runner OS: ${{ runner.os }}"
          echo "ðŸ“‹ Schedule: Option D (8AM, 12PM, 4PM, 8PM UTC)"
          echo "=================================================="
          
          echo "ðŸ” TROUBLESHOOTING CHECKLIST:"
          echo "1. âœ… Verify Supabase service status: https://status.supabase.com/"
          echo "2. âœ… Check API keys are not expired or revoked"
          echo "3. âœ… Confirm database function 'handle_schedule_daily_notifications' exists"
          echo "4. âœ… Verify GitHub Actions has not hit API rate limits"
          echo "5. âœ… Check Supabase function logs for additional error details"
          echo "6. âœ… Confirm execution window timing (should be 8, 12, 16, or 20 UTC)"
          
          # Calculate next execution opportunity
          CURRENT_HOUR=$(date -u +%H)
          if [ $CURRENT_HOUR -lt 8 ]; then
            NEXT_OPPORTUNITY="8:00 AM UTC (Today)"
          elif [ $CURRENT_HOUR -lt 12 ]; then
            NEXT_OPPORTUNITY="12:00 PM UTC (Today)"
          elif [ $CURRENT_HOUR -lt 16 ]; then
            NEXT_OPPORTUNITY="4:00 PM UTC (Today)"
          elif [ $CURRENT_HOUR -lt 20 ]; then
            NEXT_OPPORTUNITY="8:00 PM UTC (Today)"
          else
            NEXT_OPPORTUNITY="8:00 AM UTC (Tomorrow)"
          fi
          
          echo "â° Next Execution Opportunity: $NEXT_OPPORTUNITY"
          
          # Generate failure summary
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## âŒ Daily Notifications - Execution Failed
          
          | Detail | Value |
          |--------|--------|
          | ðŸ“… Failure Time | $(date -u '+%Y-%m-%d %H:%M:%S UTC') |
          | ðŸ• Scheduled Window | ${{ steps.setup.outputs.execution_window }} |
          | ðŸ†” Execution ID | \`${{ steps.setup.outputs.execution_id }}\` |
          | ðŸ”„ Trigger Type | ${{ github.event_name }} |
          | ðŸ“‹ Schedule Type | Option D (4 times daily) |
          
          ### ðŸ”§ Immediate Action Required
          1. Check Supabase service status
          2. Verify API credentials validity
          3. Review function logs in Supabase dashboard
          4. Consider manual execution for testing
          
          ### â° Recovery Information
          **Next Automatic Execution:** $NEXT_OPPORTUNITY
          
          **Schedule:** 8:00 AM, 12:00 PM, 4:00 PM, 8:00 PM UTC
          
          ### ðŸ“ž Support Resources
          - [Supabase Status](https://status.supabase.com/)
          - [GitHub Actions Documentation](https://docs.github.com/en/actions)
          EOF

      # STEP 6: CLEANUP AND FINALIZATION
      - name: ðŸ§¹ Cleanup
        if: always()
        run: |
          echo "ðŸ§¹ Performing cleanup operations"
          echo "ðŸ“Š Final execution status: ${{ job.status }}"
          echo "ðŸ• Execution window: ${{ steps.setup.outputs.execution_window }}"
          echo "ðŸ Workflow execution completed at $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          
          # Log schedule information for monitoring
          echo "ðŸ“‹ Active Schedule: Option D - 4 executions daily"
          echo "â° Execution Times: 8:00 AM, 12:00 PM, 4:00 PM, 8:00 PM UTC"

# SCHEDULE CONFIGURATION DOCUMENTATION
# =====================================
# OPTION D SELECTED: '0 8,12,16,20 * * *'
# 
# EXECUTION TIMES (UTC):
# - 08:00 UTC (8:00 AM) - Morning execution
# - 12:00 UTC (12:00 PM) - Midday execution  
# - 16:00 UTC (4:00 PM) - Afternoon execution
# - 20:00 UTC (8:00 PM) - Evening execution
#
# TOTAL EXECUTIONS: 4 per day (28 per week)
#
# TIMEZONE COVERAGE ANALYSIS:
# - 08:00 UTC covers: Asia-Pacific morning, Europe afternoon, Americas night
# - 12:00 UTC covers: Asia-Pacific afternoon, Europe evening, Americas morning
# - 16:00 UTC covers: Asia-Pacific evening, Europe night, Americas midday
# - 20:00 UTC covers: Asia-Pacific night, Europe morning, Americas afternoon
#
# ALTERNATIVE SCHEDULE OPTIONS (COMMENTED OUT):

# OPTION A: Every hour (24 executions daily)
# on:
#   schedule:
#     - cron: '0 * * * *'

# OPTION B: Every 30 minutes (48 executions daily)
# on:
#   schedule:
#     - cron: '*/30 * * * *'

# OPTION C: Every 2 hours (12 executions daily)  
# on:
#   schedule:
#     - cron: '0 */2 * * *'

# OPTION E: Business hours only (9 AM - 9 PM UTC, 13 executions daily)
# on:
#   schedule:
#     - cron: '0 9-21 * * *'